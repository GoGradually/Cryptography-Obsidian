[[타원곡선 암호]]를 이용하여 DSA 알고리즘을 구현한 알고리즘

P-256 기준
### 키 생성
1. $E_p(a, b)$ 를 설정한다.
2. parameter 는 지정되어있다.
3. p는 256비트 소수를 사용한다. (P-256 기준으로 이미 지정되어있음)
4. n 과 $G_x$, $G_y$ 를 지정한다. 이것도 P-256에서 지정되어 있다.
5. n은 매우 큰 소수를 사용하며, $nG = O$ 가 되어야 한다. 이때 $O=$ 항등원 역할 하는 무한대 점.
6. 더하다보면 무한대점 나오는 가장 빠른 n
7. 랜덤 비밀 키 d를 정한다-> $$0<d<n$$ 
8. 공개 키 Q 를 구한다 -> $$Q = dG$$

### 서명 생성
1. 평문 M을 해시에 통과시킨 값 e를 얻는다. 그때, e의 길이 $\leq$ n의 길이 이어야 하므로, 만약 e가 더 길면 e의 뒷부분을 자른다.$$e=H(M),\,\, bitlen(e) \leq bitlen(n)$$
2. 모듈러 n을 고려한 랜덤한 값 k를 고른다. $$0<k<n$$
3. $$(x1, y1)=kG$$ 로 한다.
4. $$r = x_1 \, mod\, n$$
5. 서명식 s$$s=k^{-1}(e+rd)\,mod\,n$$
6. 만약 s = 0 이거나 r = 0이면, k 값을 다시 지정하고 다시한번 서명을 생성한다.
7. 서명으로써 $$S = (r, s)$$ 를 반환한다.

### 서명 검증
0. 검증자는 $n, r, s, e, Q, G$ 를 알고있다.
1. 서명 식을 정리하면 $$s = k^{-1}(e+rd)\,mod\, n$$$$k = s^{-1}(e+rd)\, mod\, n$$$$=s^{-1}e+s^{-1}rd\, mod\, n$$가 된다.
2. $$u_1 = s^{-1}e \, mod\, n$$$$u_2 = s^{-1}r\,mod \, n$$라고 하면$$=u_1 + u_2d$$가 되므로
3. $$Q = dG$$에 의해$$kG = u_1G + u_2Q$$가 된다.
4. $$(x_1,y_1) = kG = u_1G + u_2Q$$가 되고, $(x_1, y_1) = O$ 이면 서명이 잘못된 것이고$$r\equiv x_1 \,(mod\,n)$$인지 검사한다.